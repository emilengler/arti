//! `tor-error` -- Error type XXX
//!
//! # Overview
//!
//! XXX

//#![deny(missing_docs)]
#![warn(noop_method_call)]
#![deny(unreachable_pub)]
#![deny(clippy::all)]
#![deny(clippy::await_holding_lock)]
#![deny(clippy::cargo_common_metadata)]
#![deny(clippy::cast_lossless)]
#![deny(clippy::checked_conversions)]
#![warn(clippy::clone_on_ref_ptr)]
#![warn(clippy::cognitive_complexity)]
#![deny(clippy::debug_assert_with_mut_call)]
#![deny(clippy::exhaustive_enums)]
#![deny(clippy::exhaustive_structs)]
#![deny(clippy::expl_impl_clone_on_copy)]
#![deny(clippy::fallible_impl_from)]
#![deny(clippy::implicit_clone)]
#![deny(clippy::large_stack_arrays)]
#![warn(clippy::manual_ok_or)]
#![deny(clippy::missing_docs_in_private_items)]
#![deny(clippy::missing_panics_doc)]
#![warn(clippy::needless_borrow)]
#![warn(clippy::needless_pass_by_value)]
#![warn(clippy::option_option)]
#![warn(clippy::rc_buffer)]
#![deny(clippy::ref_option_ref)]
#![warn(clippy::semicolon_if_nothing_returned)]
#![warn(clippy::trait_duplication_in_bounds)]
#![deny(clippy::unnecessary_wraps)]
#![warn(clippy::unseparated_literal_suffix)]
#![deny(clippy::unwrap_used)]

use bitflags::bitflags;
use derive_more::Display;

use std::fmt::{self, Display};
use std::mem::size_of;
use std::sync::Arc;

pub mod conversion_imports;

/// Classifying errors in all the higher-level tor crates
#[derive(Debug, Clone, Copy, PartialEq, Eq, Display)]
#[non_exhaustive]
pub enum Kind {
    /// Arti configuration is incorrect
    ///
    /// This relates only to the local configuration, not the wider Tor network.
    #[display(fmt = "arti misconfigured")]
    Misconfigured,

    /// IO error accessing local persistent state
    ///
    /// Eg, disk full or permissions problem.
    /// Usually the source will be [`std::io::Error`].
    #[display(fmt = "could not read/write persistent state")]
    PersistentStateAccessFailed,

    /// Tor client's persistent state has been corrupted
    ///
    /// This could be because of a bug in the Tor code, or because something else has been messing
    /// with thd data.
    ///
    /// This might also occur if the Tor code was upgraded and the new Tor is not compatible.
    #[display(fmt = "could not read/write persistent state")]
    PersistentStateCorrupted,

    /// Tor client's persistent state is read-only, so could not be updated
    ///
    /// Usually,
    #[display(fmt = "could not read/write persistent state")]
    PersistentStateReadOnly,

    /// Tor client is shutting down
    ///
    /// The Tor client, or possibly the whole program or some other critical part of it, is
    /// shutting down, so the operation wasn't started or could not be completed.
    #[display(fmt = "shutting down")]
    ShuttingDown,

    /// Internal error (bug)
    ///
    /// A supposedly impossible problem has arisen.  This indicates a bug in Arti.
    #[display(fmt = "internal error (bug)")]
    InternalError,

    /// Uncategorised error
    ///
    /// Something went wrong, and, sadly, we cannot categorise it
    #[display(fmt = "uncategorised error")]
    Uncategorised,

    /// Other error, not generated by Tor implementation
    ///
    /// This variant is provided in case a `tor_error::Error` needs to be made, by an application,
    /// from some other kind of non-Tor-related error.  Errors with this kind are never made by
    /// `tor-*`.
    #[display(fmt = "other error")]
    Other,
}

bitflags! {
    /// Properties that an error might have
    ///
    /// 100% correct classification of errors is not always possible.
    ///
    /// The numerical values of these flags are *not* considered part of the stable API.
    //
    // For this reason we have chosen an API which makes extending the set of flags not be an API
    // break.  When adding a flag, be careful to pick the sense that is consistent with conflating
    // "false" and "don't know".
    //
    // XXX is it OK that we are exposing the whole of the api provided by teh bitflags crate here ?
    // Doing roughly the same thing by hand woould be tedious but we could write our own macro.
    //
    // When adding a flag, add an `.is_adjective()` accessors to `TorError`
    pub struct Flags: u16 {
        /// Permanent error: there is no point trying again
        const PERMANENT = 0x01;

        /*
        /// XXX examples of other possible properties
        /// XXX if we add a property, review existing error construction sites
        ///
        /// Problem is to do with the Tor network
        ///
        /// This includes Tor network problems which were caused by failures of (or attacks on) the
        /// underlying public internet.
        pub tor_network: bool,

        /// Problem is within this local host
        ///
        /// This does not include failures by this host to talk to other hosts, unless the cause is
        /// known to lie here on this host rather than in the network.
        pub internal: bool,

        /// Broken implementation of Tor
        ///
        /// This does not include failures by this host to talk to other hosts, unless the cause is
        /// known to lie here on this host rather than in the network.
        pub bug: bool,
        */
    }
}

/// General error type for Tor implementation and APIs
///
/// This general boxed error is used when errors from multiple different layers or sources need to
/// be handled.
///
/// [`kind`] and [`flags`](`TorError::flags`) give more details.  There is always
/// a [`source`], which can perhaps be downcast to a more specific
/// error.
///
/// In addition to this, individual tor crates sometimes have their own `Error` type(s),
/// can be converted to `TorError`.
///
/// TODO The above statement is not actually true yet.  Rather than always adding the missing
/// conversions, we intend to abolish some of the crate-specific errors.
///
/// # `Display` implementation
///
/// The `Display` impl will explain that this error was something to do with Tor and
/// print a representation of the `Kind`.
///
/// In accordance with the
/// [Rust Error Handling Working Group's reccomendations](https://blog.rust-lang.org/inside-rust/2021/07/01/What-the-error-handling-project-group-is-working-towards.html#guidelines-for-implementing-displayfmt-and-errorsource)
/// the `Display` impl will *not* print the underlying [`source`].
/// Applications which print errors for display by humans should use a reporter which
/// iterates through the error source chain.
///
/// The precise text of the `Display` implementation is not stable.
///
/// [`source`]: (std::error::Error::source)
/// [`kind`]: `TorError::kind`

#[derive(Clone, Debug)] // TODO handwriting the debug impl might be nice
pub struct TorError {
    /// Categorises the error
    kind: Kind,

    /// Properties, which are separate from (and perhaps orthogonal to) the category
    flags: Flags,

    /// The underlying error, made Clone
    payload: Arc<dyn std::error::Error + Send + Sync + 'static>,
}

static_assertions::const_assert!(size_of::<TorError>() <= 3 * size_of::<usize>());

impl Display for TorError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "tor: {}", &self.kind)
    }
}

impl TorError {
    /// Wraps an error into a TorError
    pub fn new<E>(kind: Kind, flags: Flags, payload: E) -> Self
    where
        E: std::error::Error + Send + Sync + 'static,
    {
        TorError {
            kind,
            flags,
            payload: Arc::new(payload),
        }
    }

    /// Retrieve the Tor error [``Kind`]
    pub fn kind(&self) -> Kind {
        self.kind
    }
    /// Retrieve the flags giving tghe error properties [`Flags`]
    pub fn flags(&self) -> Flags {
        self.flags
    }

    /// Convenience method for accessing the [`Flags::PERMANENT`] property
    pub fn is_permanent(&self) -> bool {
        self.flags.contains(Flags::PERMANENT)
    }

    /// Disassembles the error into its component pieces
    ///
    /// If you just want access the contained actual error, consider using
    /// [`std::error::Error::source`]
    pub fn into_parts(
        self,
    ) -> (
        Kind,
        Flags,
        Arc<dyn std::error::Error + Send + Sync + 'static>,
    ) {
        (self.kind, self.flags, self.payload)
    }
}

impl std::error::Error for TorError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        Some(&self.payload)
    }
}

impl From<futures::task::SpawnError> for TorError {
    fn from(se: futures::task::SpawnError) -> TorError {
        let (kind, flags) = if se.is_shutdown() {
            (Kind::ShuttingDown, Flags::PERMANENT)
        } else {
            (Kind::ShuttingDown, Flags::empty())
        };
        TorError::new(kind, flags, se)
    }
}
